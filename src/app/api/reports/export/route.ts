/**
 * Report Export API Endpoint
 * POST /api/reports/export - Export a report in various formats
 *
 * Supports multiple export formats:
 * - CSV: Comma-separated values (text/csv)
 * - Excel: Microsoft Excel format (application/vnd.openxmlformats-officedocument.spreadsheetml.sheet)
 * - PDF: Portable Document Format (application/pdf)
 * - Markdown: Plain text with Markdown formatting (text/markdown)
 * - JSON: Raw JSON data (application/json)
 * - PNG: Image export (image/png)
 */

import { NextResponse } from "next/server";
import {
  getTemplateById,
  generateReportDataForTemplate,
  getAvailableMetrics,
} from "@/lib/mock/reports";
import type { ExportFormat, ExportOptions, ReportData, MetricDefinition } from "@/types/report-builder";

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/**
 * Create a standardized error response.
 */
function errorResponse(
  message: string,
  status: number
): NextResponse<{ success: false; error: string; timestamp: string }> {
  return NextResponse.json(
    {
      success: false,
      error: message,
      timestamp: new Date().toISOString(),
    },
    { status }
  );
}

/**
 * Format a value based on its unit type.
 */
function formatValue(value: number, unit: MetricDefinition["unit"]): string {
  switch (unit) {
    case "currency":
      return `$${value.toLocaleString("en-US", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    case "percentage":
      return `${value.toFixed(2)}%`;
    case "duration":
      // Convert seconds to human-readable format
      const minutes = Math.floor(value / 60);
      const seconds = Math.round(value % 60);
      return `${minutes}m ${seconds}s`;
    default:
      return value.toLocaleString("en-US");
  }
}

/**
 * Generate CSV content from report data.
 */
function generateCSV(report: ReportData, metrics: MetricDefinition[]): string {
  const metricsMap = new Map(metrics.map((m) => [m.id, m]));

  const headers = ["Metric", "Value", "Previous Value", "Change", "Change %", "Unit"];
  const rows = report.dataPoints.map((dp) => {
    const metric = metricsMap.get(dp.metricId);
    const unit = metric?.unit ?? "number";
    return [
      metric?.name ?? dp.metricId,
      formatValue(dp.value, unit),
      dp.previousValue !== undefined ? formatValue(dp.previousValue, unit) : "N/A",
      dp.change !== undefined ? formatValue(dp.change, unit) : "N/A",
      dp.changePercent !== undefined ? `${dp.changePercent.toFixed(2)}%` : "N/A",
      unit,
    ];
  });

  // Escape CSV values
  const escapeCSV = (val: string) => {
    if (val.includes(",") || val.includes('"') || val.includes("\n")) {
      return `"${val.replace(/"/g, '""')}"`;
    }
    return val;
  };

  return [
    headers.map(escapeCSV).join(","),
    ...rows.map((row) => row.map(escapeCSV).join(",")),
  ].join("\n");
}

/**
 * Generate Markdown content from report data.
 */
function generateMarkdown(report: ReportData, metrics: MetricDefinition[]): string {
  const metricsMap = new Map(metrics.map((m) => [m.id, m]));
  const template = report.template;

  const lines: string[] = [
    `# ${template.name}`,
    "",
    template.description,
    "",
    `**Generated:** ${new Date(report.generatedAt).toLocaleString()}`,
    "",
    "## Metrics",
    "",
    "| Metric | Value | Change | Trend |",
    "| ------ | ----- | ------ | ----- |",
  ];

  report.dataPoints.forEach((dp) => {
    const metric = metricsMap.get(dp.metricId);
    const unit = metric?.unit ?? "number";
    const value = formatValue(dp.value, unit);
    const change =
      dp.changePercent !== undefined
        ? `${dp.changePercent >= 0 ? "+" : ""}${dp.changePercent.toFixed(2)}%`
        : "N/A";
    const trendIndicator = dp.changePercent !== undefined
      ? dp.changePercent >= 0 ? "up" : "down"
      : "-";

    lines.push(`| ${metric?.name ?? dp.metricId} | ${value} | ${change} | ${trendIndicator} |`);
  });

  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("*Report generated by Unified Analytics Dashboard*");

  return lines.join("\n");
}

/**
 * Generate JSON content from report data.
 */
function generateJSON(report: ReportData, metrics: MetricDefinition[]): string {
  const metricsMap = new Map(metrics.map((m) => [m.id, m]));

  const enrichedData = {
    template: {
      id: report.template.id,
      name: report.template.name,
      description: report.template.description,
    },
    generatedAt: report.generatedAt,
    metrics: report.dataPoints.map((dp) => {
      const metric = metricsMap.get(dp.metricId);
      return {
        id: dp.metricId,
        name: metric?.name ?? dp.metricId,
        category: metric?.category ?? "unknown",
        unit: metric?.unit ?? "number",
        value: dp.value,
        previousValue: dp.previousValue,
        change: dp.change,
        changePercent: dp.changePercent,
        trend: dp.trend,
      };
    }),
  };

  return JSON.stringify(enrichedData, null, 2);
}

/**
 * Generate mock PDF content (in real implementation, use a PDF library).
 * For mock purposes, returns a base64-encoded placeholder.
 */
function generateMockPDF(report: ReportData): ArrayBuffer {
  // In a real implementation, you would use a library like jsPDF or pdfmake
  // For mock purposes, we'll create a simple text representation
  const content = `%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << >> >>
endobj
4 0 obj
<< /Length 44 >>
stream
BT
/F1 12 Tf
100 700 Td
(${report.template.name} - Report) Tj
ET
endstream
endobj
xref
0 5
0000000000 65535 f
0000000009 00000 n
0000000058 00000 n
0000000115 00000 n
0000000226 00000 n
trailer
<< /Size 5 /Root 1 0 R >>
startxref
320
%%EOF`;

  const encoder = new TextEncoder();
  return encoder.encode(content).buffer;
}

/**
 * Generate mock Excel content (in real implementation, use xlsx library).
 * For mock purposes, returns CSV data as the base.
 */
function generateMockExcel(report: ReportData, metrics: MetricDefinition[]): ArrayBuffer {
  // In a real implementation, you would use a library like xlsx or exceljs
  // For mock purposes, we'll return CSV content as a buffer
  const csvContent = generateCSV(report, metrics);
  const encoder = new TextEncoder();
  return encoder.encode(csvContent).buffer;
}

/**
 * Generate mock PNG content (in real implementation, use canvas or puppeteer).
 * For mock purposes, returns a minimal valid PNG.
 */
function generateMockPNG(): ArrayBuffer {
  // Minimal valid 1x1 white PNG
  const pngBytes = new Uint8Array([
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, // PNG signature
    0x00, 0x00, 0x00, 0x0d, // IHDR chunk length
    0x49, 0x48, 0x44, 0x52, // IHDR
    0x00, 0x00, 0x00, 0x01, // width: 1
    0x00, 0x00, 0x00, 0x01, // height: 1
    0x08, 0x02,             // bit depth: 8, color type: 2 (RGB)
    0x00, 0x00, 0x00,       // compression, filter, interlace
    0x90, 0x77, 0x53, 0xde, // CRC
    0x00, 0x00, 0x00, 0x0c, // IDAT chunk length
    0x49, 0x44, 0x41, 0x54, // IDAT
    0x08, 0xd7, 0x63, 0xf8, 0xff, 0xff, 0xff, 0x00,
    0x05, 0xfe, 0x02, 0xfe, // CRC
    0x00, 0x00, 0x00, 0x00, // IEND chunk length
    0x49, 0x45, 0x4e, 0x44, // IEND
    0xae, 0x42, 0x60, 0x82, // CRC
  ]);
  return pngBytes.buffer;
}

/**
 * Get content type for export format.
 */
function getContentType(format: ExportFormat): string {
  switch (format) {
    case "csv":
      return "text/csv";
    case "excel":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "pdf":
      return "application/pdf";
    case "markdown":
      return "text/markdown";
    case "json":
      return "application/json";
    case "png":
      return "image/png";
    default:
      return "application/octet-stream";
  }
}

/**
 * Get file extension for export format.
 */
function getFileExtension(format: ExportFormat): string {
  switch (format) {
    case "csv":
      return ".csv";
    case "excel":
      return ".xlsx";
    case "pdf":
      return ".pdf";
    case "markdown":
      return ".md";
    case "json":
      return ".json";
    case "png":
      return ".png";
    default:
      return ".bin";
  }
}

/**
 * Validate export request body.
 */
function validateExportRequest(
  body: unknown
): { valid: true; data: ExportRequestData } | { valid: false; error: string } {
  if (!body || typeof body !== "object") {
    return { valid: false, error: "Request body is required" };
  }

  const input = body as Record<string, unknown>;

  if (typeof input.templateId !== "string" || input.templateId.trim().length === 0) {
    return { valid: false, error: "Template ID is required" };
  }

  const validFormats: ExportFormat[] = ["csv", "excel", "pdf", "markdown", "json", "png"];
  if (typeof input.format !== "string" || !validFormats.includes(input.format as ExportFormat)) {
    return {
      valid: false,
      error: `Invalid format. Must be one of: ${validFormats.join(", ")}`,
    };
  }

  const options: Partial<ExportOptions> = {
    format: input.format as ExportFormat,
  };

  // Validate optional fields
  if (input.options && typeof input.options === "object") {
    const opts = input.options as Record<string, unknown>;

    if (opts.includeCharts !== undefined && typeof opts.includeCharts !== "boolean") {
      return { valid: false, error: "includeCharts must be a boolean" };
    }
    options.includeCharts = opts.includeCharts as boolean | undefined;

    if (opts.filename !== undefined && typeof opts.filename !== "string") {
      return { valid: false, error: "filename must be a string" };
    }
    options.filename = opts.filename as string | undefined;

    if (opts.dateRange !== undefined) {
      if (typeof opts.dateRange !== "object" || opts.dateRange === null) {
        return { valid: false, error: "dateRange must be an object with start and end" };
      }
      const dr = opts.dateRange as Record<string, unknown>;
      if (typeof dr.start !== "string" || typeof dr.end !== "string") {
        return { valid: false, error: "dateRange.start and dateRange.end must be strings" };
      }
      options.dateRange = { start: dr.start, end: dr.end };
    }
  }

  return {
    valid: true,
    data: {
      templateId: input.templateId.trim(),
      format: input.format as ExportFormat,
      options: options as ExportOptions,
    },
  };
}

interface ExportRequestData {
  templateId: string;
  format: ExportFormat;
  options: ExportOptions;
}

// =============================================================================
// ROUTE HANDLER
// =============================================================================

/**
 * POST /api/reports/export
 * Export a report in the specified format.
 */
export async function POST(
  request: Request
): Promise<NextResponse> {
  try {
    const body = await request.json();
    const validation = validateExportRequest(body);

    if (!validation.valid) {
      return errorResponse(validation.error, 400);
    }

    const { templateId, format, options } = validation.data;

    // Get template and generate report
    const template = getTemplateById(templateId);
    if (!template) {
      return errorResponse("Template not found", 404);
    }

    const report = generateReportDataForTemplate(templateId);
    if (!report) {
      return errorResponse("Failed to generate report data", 500);
    }

    const metrics = getAvailableMetrics();
    const filename = options.filename ?? `${template.name.replace(/\s+/g, "-").toLowerCase()}-report`;
    const contentType = getContentType(format);
    const extension = getFileExtension(format);

    let responseBody: string | ArrayBuffer;

    // Generate content based on format
    switch (format) {
      case "csv":
        responseBody = generateCSV(report, metrics);
        break;
      case "markdown":
        responseBody = generateMarkdown(report, metrics);
        break;
      case "json":
        responseBody = generateJSON(report, metrics);
        break;
      case "pdf":
        responseBody = generateMockPDF(report);
        break;
      case "excel":
        responseBody = generateMockExcel(report, metrics);
        break;
      case "png":
        responseBody = generateMockPNG();
        break;
      default:
        return errorResponse("Unsupported format", 400);
    }

    // Return appropriate response
    if (typeof responseBody === "string") {
      return new NextResponse(responseBody, {
        status: 200,
        headers: {
          "Content-Type": contentType,
          "Content-Disposition": `attachment; filename="${filename}${extension}"`,
          "Cache-Control": "no-store",
        },
      });
    } else {
      return new NextResponse(responseBody, {
        status: 200,
        headers: {
          "Content-Type": contentType,
          "Content-Disposition": `attachment; filename="${filename}${extension}"`,
          "Content-Length": responseBody.byteLength.toString(),
          "Cache-Control": "no-store",
        },
      });
    }
  } catch (error) {
    console.error("[api/reports/export] POST Error:", error);
    return errorResponse("Failed to export report", 500);
  }
}
